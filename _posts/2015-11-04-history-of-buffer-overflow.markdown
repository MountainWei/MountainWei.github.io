---
layout:     post
title:      "History of Buffer Overflow"
subtitle:   " Part I 基础知识"
date:       2015-11-04 22:00:00
author:     "Liuv"
header-img: "img/post-bg-2015-11-04.jpg"
tags:
    - 系统安全
    - shellcode
---

>  在缓冲区溢出的攻防上，微软与世界各地的黑客们进行了激烈的较量，难解难分。

## 0x01 前言
<br>最近读了一篇有关内存重用攻击防御的论文，里面涉及到了ROP，Heap Spray这些常见的攻击技术，在调研的过程中逐渐发现这些技术与缓冲区溢出有着千丝万缕的关系，核心思想都是通过控制堆栈和寄存器来达到改变程序控制流的目的。
<br>因此，我决定开一篇专题，对缓冲区溢出、ROP、Heap Spray这些常见的攻击技术的发展史进行一个梳理。
<br>当然，在安全领域，攻击和防御都是相伴相生的，在介绍攻击的过程中，也会对DEP、ASLR、CFI\CFG这些安全技术进行讲解。在正式介绍这些技术之前，我会先介绍有关操作系统方面的知识。

## 0x02 程序内存布局（32位）
<br>在进行缓冲区溢出攻击之前，需要对当前操作系统中程序的内存布局有一个清晰的了解。
<br>现代的应用程序都运行在一个虚拟内存空间里，在32位的系统里，这个内存空间拥有4GB的寻址能力。现代的应用程序可以直接使用32位的地址进行寻址，整个内存是一个统一的地址空间，用户可以使用一个32位的指针访问任意内存位置。
<br>从宏观上来看，操作系统将内存分成了代码段、数据段、堆、栈、内核空间四部分，其中代码段、数据段、堆、栈组合成用户空间。Windows默认情况下会将高地址的2GB分配给内核（也可配置为1GB），而Linux默认情况下将高地址的1GB空间分配给内核。
<br>计算机程序本质上是由bss segment、data segment、text segment这三个段组成的,程序运行过程还需要堆、栈来完成内存分配、函数调用等功能。下面对这五个内存区域进行详细介绍。
<ul>
    <li>
        <b>BSS segment:</b>BSS段通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。
    </li>
    <li>
        <b>Ro-data segment:</b>只读数据段通常用来存放字符串常量
    </li>
    <li>
        <b>Data segment：</b>数据段通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。
    </li>
    <li>
        <b>Text segment：</b>代码段通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。
    </li>
    <li>
        <b>Heap：</b>堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）
    </li>
    <li>
        <b>Stack：</b>栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。
    </li>
</ul>
下图是linux中的地址空间格局。
![img](/img/in-post/post-memory-layout-1.jpg)
<br>高级语言写出的程序经过编译链接，最终会变成可执行文件。当可执行文件被装载运行后，就成了所谓的进程。可执行文件代码段中包含的二进制级别的机器代码会被装入内存的代码区。处理器将到内存的这个区域一条一条地取出指令和操作数，并送入运算逻辑单元进行运算。如果代码中请求开辟动态内存，则会在内存的堆区分配一块大小合适的区域返回给代码区的代码使用。当函数调用发生时，函数的调用关系等信息会动态地保存在内存的栈区，以供处理器在执行完被调用函数的代码时，返回母函数。
<br>当数据存储时，分为常量和变量两种情况：
<ul>
    <li>
        <b>常量：</b>对于整型常量和字符型常量，由于不需要写操作，编译器会将其直接编译在代码之中，因此不需要存储。对于字符串常量，编译器将其放入只读数据段.rdata;对于相同的字符串常量，编译器会优化并只存储一次。
    </li>
    <li>
        <b>变量：</b>
            <ul>
                <li>静态变量和全局变量：未初始化的，存储于.bss ； 初始化的，存储于.data</li>
                <li>自动变量：局部变量存储于stack ； 动态分配的内存，存储于heap。</li>
                <li>寄存器变量：存储位置在CPU寄存器内</li>
            </ul>
    </li>
</ul>
<br>在这里额外说一下多线程的内容。多线程程序和普通程序在内存中的不同只要表现在栈的不同，每一个线程一个栈，所以线程的局部变量不会受到其他线程的影响。而.text, .data. .bss等部分段是各个线程共享的，所以线程间通信很简单，可以直接在这些共享内存中存取就可以了。

## 0x03 函数调用过程
未完待续











